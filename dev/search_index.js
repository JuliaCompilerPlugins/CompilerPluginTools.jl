var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CompilerPluginTools","category":"page"},{"location":"#CompilerPluginTools","page":"Home","title":"CompilerPluginTools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CompilerPluginTools]","category":"page"},{"location":"#CompilerPluginTools.JuliaLikeInterpreter","page":"Home","title":"CompilerPluginTools.JuliaLikeInterpreter","text":"JuliaLikeInterpreter <: AbstractInterpreter\n\nAbstract type for julia-like interpreter. The subtype of it usually modifies the native julia interpreter a little bit by overloading certain abstract interpretation interface, but forward most of the interfaces to the native interpreter.\n\n\n\n\n\n","category":"type"},{"location":"#Base.parent-Tuple{JuliaLikeInterpreter}","page":"Home","title":"Base.parent","text":"parent(interp::JuliaLikeInterpreter)\n\nReturn the native interpreter of Julia.\n\n\n\n\n\n","category":"method"},{"location":"#CompilerPluginTools.anymap-Tuple{Any, Any}","page":"Home","title":"CompilerPluginTools.anymap","text":"anymap(f, xs)\n\nLike map, but force to create Vector{Any}.\n\n\n\n\n\n","category":"method"},{"location":"#CompilerPluginTools.code_ircode-Tuple{Any, Any}","page":"Home","title":"CompilerPluginTools.code_ircode","text":"code_ircode([pass, ]f, types; world=get_world_counter(), interp=NativeInterpreter(world))\n\nGet IRCode by given function f and its argument types types. An option argument pass can be specified as a transform function on IRCode during type inference.\n\n\n\n\n\n","category":"method"},{"location":"#CompilerPluginTools.code_ircode_by_mi-Tuple{Any, Core.MethodInstance}","page":"Home","title":"CompilerPluginTools.code_ircode_by_mi","text":"code_ircode_by_mi(f, mi::MethodInstance; world=get_world_counter(), interp=NativeInterpreter(world))\n\nReturn the IRCode object along with inferred return type.\n\nArguments\n\nf(ir::IRCode, sv::OptimizationState) -> IRCode: optimization passes to run.\nmi::MethodInstance: method instance.\n\nKwargs\n\nworld::Int: world number, default is calling Core.Compiler.get_world_counter.\ninterp::AbstractInterpreter: the interpreter to use for inference.\n\n\n\n\n\n","category":"method"},{"location":"#CompilerPluginTools.code_ircode_by_mi-Tuple{Core.MethodInstance}","page":"Home","title":"CompilerPluginTools.code_ircode_by_mi","text":"code_ircode_by_mi(mi::MethodInstance; world=get_world_counter(), interp=NativeInterpreter(world))\n\nThe default code_ircode_by_mi that uses the default Julia compiler optimization passes. See also code_ircode_by_mi.\n\n\n\n\n\n","category":"method"},{"location":"#CompilerPluginTools.code_ircode_by_signature-Tuple{Any, Any}","page":"Home","title":"CompilerPluginTools.code_ircode_by_signature","text":"code_ircode_by_signature([pass, ]sig; world=get_world_counter(), interp=NativeInterpreter(world))\n\nGet IRCode by given signature, one can use the first argument to transform the IRCode during interpretation.\n\n\n\n\n\n","category":"method"},{"location":"#CompilerPluginTools.const_invoke!-Tuple{Any, IRCode, GlobalRef}","page":"Home","title":"CompilerPluginTools.const_invoke!","text":"const_invoke!(f, ir::IRCode, ref::GlobalRef)\n\nReplace the function invoke Expr(:invoke, _, ref, args...) with f(args...) if its arguments args are all constant.\n\n\n\n\n\n","category":"method"},{"location":"#CompilerPluginTools.default_julia_pass-Tuple{IRCode, Core.Compiler.OptimizationState}","page":"Home","title":"CompilerPluginTools.default_julia_pass","text":"default_julia_pass(ir::IRCode, sv::OptimizationState)\n\nThe default julia optimization pass.\n\n\n\n\n\n","category":"method"},{"location":"#CompilerPluginTools.inline_const!-Tuple{IRCode}","page":"Home","title":"CompilerPluginTools.inline_const!","text":"inline_const!(ir::IRCode)\n\nThis performs constant propagation on IRCode so after the constant propagation during abstract interpretation, we can force inline constant values in IRCode.\n\n\n\n\n\n","category":"method"},{"location":"#CompilerPluginTools.no_pass-Tuple{IRCode, Core.Compiler.OptimizationState}","page":"Home","title":"CompilerPluginTools.no_pass","text":"no_pass(ir::IRCode, ::OptimizationState)\n\nNo pass.\n\n\n\n\n\n","category":"method"},{"location":"#CompilerPluginTools.optimize","page":"Home","title":"CompilerPluginTools.optimize","text":"optimize(interp::JuliaLikeInterpreter[, state::OptimizationState], ir::IRCode)\n\nThis method is for overloading, it will be executed after running Julia optimizers. If you wish to customize the default Julia optimization passes, consider overloading Core.Compiler.optimize(interp, opt, params, result).\n\n\n\n\n\n","category":"function"},{"location":"#CompilerPluginTools.permute_stmts!-Tuple{IRCode, Vector{Int64}}","page":"Home","title":"CompilerPluginTools.permute_stmts!","text":"permute_stmts!(ir::IRCode, perm::Vector{Int})\n\nPermute statements according to perm.\n\n\n\n\n\n","category":"method"},{"location":"#CompilerPluginTools.typeinf_lock-Tuple{Any}","page":"Home","title":"CompilerPluginTools.typeinf_lock","text":"typeinf_lock(f)\n\nType inference lock. This prevents you from recursing into type inference when you don't want. equivalent to the following code, which you may see in Julia compiler implementation.\n\nccall(:jl_typeinf_begin, Cvoid, ())\nret = f()\nccall(:jl_typeinf_end, Cvoid, ())\nreturn ret\n\n\n\n\n\n","category":"method"},{"location":"#CompilerPluginTools.@codeinfo-Tuple{Any}","page":"Home","title":"CompilerPluginTools.@codeinfo","text":"@codeinfo begin\n    <stmt>::<type>\nend\n\nCreate a typed CodeInfo object, if field <type> is not specified, it will use Any.\n\n\n\n\n\n","category":"macro"}]
}
