var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CompilerPluginTools","category":"page"},{"location":"#CompilerPluginTools","page":"Home","title":"CompilerPluginTools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CompilerPluginTools]","category":"page"},{"location":"#CompilerPluginTools.JuliaLikeInterpreter","page":"Home","title":"CompilerPluginTools.JuliaLikeInterpreter","text":"JuliaLikeInterpreter <: AbstractInterpreter\n\nAbstract type for julia-like interpreter. The subtype of it usually modifies the native julia interpreter a little bit by overloading certain abstract interpretation interface, but forward most of the interfaces to the native interpreter.\n\n\n\n\n\n","category":"type"},{"location":"#Base.parent-Tuple{JuliaLikeInterpreter}","page":"Home","title":"Base.parent","text":"parent(interp::JuliaLikeInterpreter)\n\nReturn the native interpreter of Julia.\n\n\n\n\n\n","category":"method"},{"location":"#CompilerPluginTools.code_ircode-Tuple{Any, Any}","page":"Home","title":"CompilerPluginTools.code_ircode","text":"code_ircode([pass, ]f, types; world=get_world_counter(), interp=NativeInterpreter(world))\n\nGet IRCode by given function f and its argument types types. An option argument pass can be specified as a transform function on IRCode during type inference.\n\n\n\n\n\n","category":"method"},{"location":"#CompilerPluginTools.code_ircode_by_mi-Tuple{Any, Core.MethodInstance}","page":"Home","title":"CompilerPluginTools.code_ircode_by_mi","text":"code_ircode_by_mi(f, mi::MethodInstance; world=get_world_counter(), interp=NativeInterpreter(world))\n\nReturn the IRCode object along with inferred return type.\n\nArguments\n\nf(ir::IRCode, sv::OptimizationState) -> IRCode: optimization passes to run.\nmi::MethodInstance: method instance.\n\nKwargs\n\nworld::Int: world number, default is calling Core.Compiler.get_world_counter.\ninterp::AbstractInterpreter: the interpreter to use for inference.\n\n\n\n\n\n","category":"method"},{"location":"#CompilerPluginTools.code_ircode_by_mi-Tuple{Core.MethodInstance}","page":"Home","title":"CompilerPluginTools.code_ircode_by_mi","text":"code_ircode_by_mi(mi::MethodInstance; world=get_world_counter(), interp=NativeInterpreter(world))\n\nThe default code_ircode_by_mi that uses the default Julia compiler optimization passes. See also code_ircode_by_mi.\n\n\n\n\n\n","category":"method"},{"location":"#CompilerPluginTools.code_ircode_by_signature-Tuple{Any, Any}","page":"Home","title":"CompilerPluginTools.code_ircode_by_signature","text":"code_ircode_by_signature([pass, ]sig; world=get_world_counter(), interp=NativeInterpreter(world))\n\nGet IRCode by given signature, one can use the first argument to transform the IRCode during interpretation.\n\n\n\n\n\n","category":"method"},{"location":"#CompilerPluginTools.inline_const!-Tuple{IRCode}","page":"Home","title":"CompilerPluginTools.inline_const!","text":"inline_const!(ir::IRCode)\n\nThis performs constant propagation on IRCode so after the constant propagation during abstract interpretation, we can force inline constant values in IRCode.\n\n\n\n\n\n","category":"method"},{"location":"#CompilerPluginTools.optimize","page":"Home","title":"CompilerPluginTools.optimize","text":"optimize(interp::JuliaLikeInterpreter[, state::OptimizationState], ir::IRCode)\n\nThis method is for overloading, it will be executed after running Julia optimizers. If you wish to customize the default Julia optimization passes, consider overloading Core.Compiler.optimize(interp, opt, params, result).\n\n\n\n\n\n","category":"function"},{"location":"#CompilerPluginTools.typeinf_lock-Tuple{Any}","page":"Home","title":"CompilerPluginTools.typeinf_lock","text":"typeinf_lock(f)\n\nType inference lock. This prevents you from recursing into type inference when you don't want. equivalent to the following code, which you may see in Julia compiler implementation.\n\nccall(:jl_typeinf_begin, Cvoid, ())\nret = f()\nccall(:jl_typeinf_end, Cvoid, ())\nreturn ret\n\n\n\n\n\n","category":"method"}]
}
